// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package snakemini

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MatchMonitorClient is the client API for MatchMonitor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MatchMonitorClient interface {
	Update(ctx context.Context, in *BroadcastConfigs, opts ...grpc.CallOption) (*ReplyEmpty, error)
}

type matchMonitorClient struct {
	cc grpc.ClientConnInterface
}

func NewMatchMonitorClient(cc grpc.ClientConnInterface) MatchMonitorClient {
	return &matchMonitorClient{cc}
}

func (c *matchMonitorClient) Update(ctx context.Context, in *BroadcastConfigs, opts ...grpc.CallOption) (*ReplyEmpty, error) {
	out := new(ReplyEmpty)
	err := c.cc.Invoke(ctx, "/pb.MatchMonitor/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MatchMonitorServer is the server API for MatchMonitor service.
// All implementations should embed UnimplementedMatchMonitorServer
// for forward compatibility
type MatchMonitorServer interface {
	Update(context.Context, *BroadcastConfigs) (*ReplyEmpty, error)
}

// UnimplementedMatchMonitorServer should be embedded to have forward compatible implementations.
type UnimplementedMatchMonitorServer struct {
}

func (UnimplementedMatchMonitorServer) Update(context.Context, *BroadcastConfigs) (*ReplyEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeMatchMonitorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MatchMonitorServer will
// result in compilation errors.
type UnsafeMatchMonitorServer interface {
	mustEmbedUnimplementedMatchMonitorServer()
}

func RegisterMatchMonitorServer(s grpc.ServiceRegistrar, srv MatchMonitorServer) {
	s.RegisterService(&MatchMonitor_ServiceDesc, srv)
}

func _MatchMonitor_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastConfigs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMonitorServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MatchMonitor/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMonitorServer).Update(ctx, req.(*BroadcastConfigs))
	}
	return interceptor(ctx, in, info, handler)
}

// MatchMonitor_ServiceDesc is the grpc.ServiceDesc for MatchMonitor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MatchMonitor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.MatchMonitor",
	HandlerType: (*MatchMonitorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Update",
			Handler:    _MatchMonitor_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "snakemini/service.proto",
}

// MatchClient is the client API for Match service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MatchClient interface {
	BindMatch(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*BindResponse, error)
	GetInGameState(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*InGameStateReply, error)
	Disconnect(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*InGameStateReply, error)
	MatchHandle(ctx context.Context, in *InternalReq, opts ...grpc.CallOption) (*RpcResponse, error)
	GroupInfo(ctx context.Context, in *GroupInfoReq, opts ...grpc.CallOption) (*GroupInfoRsp, error)
	SyncUserState(ctx context.Context, in *SyncUserStateReq, opts ...grpc.CallOption) (*SyncUserStateRsp, error)
}

type matchClient struct {
	cc grpc.ClientConnInterface
}

func NewMatchClient(cc grpc.ClientConnInterface) MatchClient {
	return &matchClient{cc}
}

func (c *matchClient) BindMatch(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*BindResponse, error) {
	out := new(BindResponse)
	err := c.cc.Invoke(ctx, "/pb.Match/BindMatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchClient) GetInGameState(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*InGameStateReply, error) {
	out := new(InGameStateReply)
	err := c.cc.Invoke(ctx, "/pb.Match/GetInGameState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchClient) Disconnect(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*InGameStateReply, error) {
	out := new(InGameStateReply)
	err := c.cc.Invoke(ctx, "/pb.Match/Disconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchClient) MatchHandle(ctx context.Context, in *InternalReq, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/pb.Match/MatchHandle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchClient) GroupInfo(ctx context.Context, in *GroupInfoReq, opts ...grpc.CallOption) (*GroupInfoRsp, error) {
	out := new(GroupInfoRsp)
	err := c.cc.Invoke(ctx, "/pb.Match/GroupInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchClient) SyncUserState(ctx context.Context, in *SyncUserStateReq, opts ...grpc.CallOption) (*SyncUserStateRsp, error) {
	out := new(SyncUserStateRsp)
	err := c.cc.Invoke(ctx, "/pb.Match/SyncUserState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MatchServer is the server API for Match service.
// All implementations should embed UnimplementedMatchServer
// for forward compatibility
type MatchServer interface {
	BindMatch(context.Context, *UidRequest) (*BindResponse, error)
	GetInGameState(context.Context, *UidRequest) (*InGameStateReply, error)
	Disconnect(context.Context, *UidRequest) (*InGameStateReply, error)
	MatchHandle(context.Context, *InternalReq) (*RpcResponse, error)
	GroupInfo(context.Context, *GroupInfoReq) (*GroupInfoRsp, error)
	SyncUserState(context.Context, *SyncUserStateReq) (*SyncUserStateRsp, error)
}

// UnimplementedMatchServer should be embedded to have forward compatible implementations.
type UnimplementedMatchServer struct {
}

func (UnimplementedMatchServer) BindMatch(context.Context, *UidRequest) (*BindResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BindMatch not implemented")
}
func (UnimplementedMatchServer) GetInGameState(context.Context, *UidRequest) (*InGameStateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInGameState not implemented")
}
func (UnimplementedMatchServer) Disconnect(context.Context, *UidRequest) (*InGameStateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedMatchServer) MatchHandle(context.Context, *InternalReq) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchHandle not implemented")
}
func (UnimplementedMatchServer) GroupInfo(context.Context, *GroupInfoReq) (*GroupInfoRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GroupInfo not implemented")
}
func (UnimplementedMatchServer) SyncUserState(context.Context, *SyncUserStateReq) (*SyncUserStateRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncUserState not implemented")
}

// UnsafeMatchServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MatchServer will
// result in compilation errors.
type UnsafeMatchServer interface {
	mustEmbedUnimplementedMatchServer()
}

func RegisterMatchServer(s grpc.ServiceRegistrar, srv MatchServer) {
	s.RegisterService(&Match_ServiceDesc, srv)
}

func _Match_BindMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchServer).BindMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Match/BindMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchServer).BindMatch(ctx, req.(*UidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_GetInGameState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchServer).GetInGameState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Match/GetInGameState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchServer).GetInGameState(ctx, req.(*UidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Match/Disconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchServer).Disconnect(ctx, req.(*UidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_MatchHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InternalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchServer).MatchHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Match/MatchHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchServer).MatchHandle(ctx, req.(*InternalReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_GroupInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchServer).GroupInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Match/GroupInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchServer).GroupInfo(ctx, req.(*GroupInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_SyncUserState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncUserStateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchServer).SyncUserState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Match/SyncUserState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchServer).SyncUserState(ctx, req.(*SyncUserStateReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Match_ServiceDesc is the grpc.ServiceDesc for Match service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Match_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Match",
	HandlerType: (*MatchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BindMatch",
			Handler:    _Match_BindMatch_Handler,
		},
		{
			MethodName: "GetInGameState",
			Handler:    _Match_GetInGameState_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _Match_Disconnect_Handler,
		},
		{
			MethodName: "MatchHandle",
			Handler:    _Match_MatchHandle_Handler,
		},
		{
			MethodName: "GroupInfo",
			Handler:    _Match_GroupInfo_Handler,
		},
		{
			MethodName: "SyncUserState",
			Handler:    _Match_SyncUserState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "snakemini/service.proto",
}

// GatewayMonitorClient is the client API for GatewayMonitor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayMonitorClient interface {
	Update(ctx context.Context, in *BroadcastConfigs, opts ...grpc.CallOption) (*ReplyEmpty, error)
	Reload(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*ReplyEmpty, error)
}

type gatewayMonitorClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayMonitorClient(cc grpc.ClientConnInterface) GatewayMonitorClient {
	return &gatewayMonitorClient{cc}
}

func (c *gatewayMonitorClient) Update(ctx context.Context, in *BroadcastConfigs, opts ...grpc.CallOption) (*ReplyEmpty, error) {
	out := new(ReplyEmpty)
	err := c.cc.Invoke(ctx, "/pb.GatewayMonitor/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayMonitorClient) Reload(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*ReplyEmpty, error) {
	out := new(ReplyEmpty)
	err := c.cc.Invoke(ctx, "/pb.GatewayMonitor/Reload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayMonitorServer is the server API for GatewayMonitor service.
// All implementations should embed UnimplementedGatewayMonitorServer
// for forward compatibility
type GatewayMonitorServer interface {
	Update(context.Context, *BroadcastConfigs) (*ReplyEmpty, error)
	Reload(context.Context, *UidRequest) (*ReplyEmpty, error)
}

// UnimplementedGatewayMonitorServer should be embedded to have forward compatible implementations.
type UnimplementedGatewayMonitorServer struct {
}

func (UnimplementedGatewayMonitorServer) Update(context.Context, *BroadcastConfigs) (*ReplyEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedGatewayMonitorServer) Reload(context.Context, *UidRequest) (*ReplyEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reload not implemented")
}

// UnsafeGatewayMonitorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayMonitorServer will
// result in compilation errors.
type UnsafeGatewayMonitorServer interface {
	mustEmbedUnimplementedGatewayMonitorServer()
}

func RegisterGatewayMonitorServer(s grpc.ServiceRegistrar, srv GatewayMonitorServer) {
	s.RegisterService(&GatewayMonitor_ServiceDesc, srv)
}

func _GatewayMonitor_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastConfigs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayMonitorServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.GatewayMonitor/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayMonitorServer).Update(ctx, req.(*BroadcastConfigs))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayMonitor_Reload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayMonitorServer).Reload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.GatewayMonitor/Reload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayMonitorServer).Reload(ctx, req.(*UidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GatewayMonitor_ServiceDesc is the grpc.ServiceDesc for GatewayMonitor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GatewayMonitor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.GatewayMonitor",
	HandlerType: (*GatewayMonitorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Update",
			Handler:    _GatewayMonitor_Update_Handler,
		},
		{
			MethodName: "Reload",
			Handler:    _GatewayMonitor_Reload_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "snakemini/service.proto",
}

// GatewayClient is the client API for Gateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayClient interface {
	GatewayHandle(ctx context.Context, in *InternalReq, opts ...grpc.CallOption) (*RpcResponse, error)
	PushClient(ctx context.Context, in *PushMsg, opts ...grpc.CallOption) (*UidList, error)
}

type gatewayClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayClient(cc grpc.ClientConnInterface) GatewayClient {
	return &gatewayClient{cc}
}

func (c *gatewayClient) GatewayHandle(ctx context.Context, in *InternalReq, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/pb.Gateway/GatewayHandle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) PushClient(ctx context.Context, in *PushMsg, opts ...grpc.CallOption) (*UidList, error) {
	out := new(UidList)
	err := c.cc.Invoke(ctx, "/pb.Gateway/PushClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayServer is the server API for Gateway service.
// All implementations should embed UnimplementedGatewayServer
// for forward compatibility
type GatewayServer interface {
	GatewayHandle(context.Context, *InternalReq) (*RpcResponse, error)
	PushClient(context.Context, *PushMsg) (*UidList, error)
}

// UnimplementedGatewayServer should be embedded to have forward compatible implementations.
type UnimplementedGatewayServer struct {
}

func (UnimplementedGatewayServer) GatewayHandle(context.Context, *InternalReq) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GatewayHandle not implemented")
}
func (UnimplementedGatewayServer) PushClient(context.Context, *PushMsg) (*UidList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushClient not implemented")
}

// UnsafeGatewayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayServer will
// result in compilation errors.
type UnsafeGatewayServer interface {
	mustEmbedUnimplementedGatewayServer()
}

func RegisterGatewayServer(s grpc.ServiceRegistrar, srv GatewayServer) {
	s.RegisterService(&Gateway_ServiceDesc, srv)
}

func _Gateway_GatewayHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InternalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).GatewayHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Gateway/GatewayHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).GatewayHandle(ctx, req.(*InternalReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_PushClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).PushClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Gateway/PushClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).PushClient(ctx, req.(*PushMsg))
	}
	return interceptor(ctx, in, info, handler)
}

// Gateway_ServiceDesc is the grpc.ServiceDesc for Gateway service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Gateway_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Gateway",
	HandlerType: (*GatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GatewayHandle",
			Handler:    _Gateway_GatewayHandle_Handler,
		},
		{
			MethodName: "PushClient",
			Handler:    _Gateway_PushClient_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "snakemini/service.proto",
}

// RouteClient is the client API for Route service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RouteClient interface {
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*ReplyEmpty, error)
	HeartBeat(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*ReplyEmpty, error)
}

type routeClient struct {
	cc grpc.ClientConnInterface
}

func NewRouteClient(cc grpc.ClientConnInterface) RouteClient {
	return &routeClient{cc}
}

func (c *routeClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*ReplyEmpty, error) {
	out := new(ReplyEmpty)
	err := c.cc.Invoke(ctx, "/pb.Route/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) HeartBeat(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*ReplyEmpty, error) {
	out := new(ReplyEmpty)
	err := c.cc.Invoke(ctx, "/pb.Route/HeartBeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RouteServer is the server API for Route service.
// All implementations should embed UnimplementedRouteServer
// for forward compatibility
type RouteServer interface {
	Register(context.Context, *RegisterRequest) (*ReplyEmpty, error)
	HeartBeat(context.Context, *RegisterRequest) (*ReplyEmpty, error)
}

// UnimplementedRouteServer should be embedded to have forward compatible implementations.
type UnimplementedRouteServer struct {
}

func (UnimplementedRouteServer) Register(context.Context, *RegisterRequest) (*ReplyEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedRouteServer) HeartBeat(context.Context, *RegisterRequest) (*ReplyEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HeartBeat not implemented")
}

// UnsafeRouteServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RouteServer will
// result in compilation errors.
type UnsafeRouteServer interface {
	mustEmbedUnimplementedRouteServer()
}

func RegisterRouteServer(s grpc.ServiceRegistrar, srv RouteServer) {
	s.RegisterService(&Route_ServiceDesc, srv)
}

func _Route_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Route/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_HeartBeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).HeartBeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Route/HeartBeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).HeartBeat(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Route_ServiceDesc is the grpc.ServiceDesc for Route service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Route_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Route",
	HandlerType: (*RouteServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Route_Register_Handler,
		},
		{
			MethodName: "HeartBeat",
			Handler:    _Route_HeartBeat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "snakemini/service.proto",
}

// RelayClient is the client API for Relay service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RelayClient interface {
	RelayHandle(ctx context.Context, in *InternalReq, opts ...grpc.CallOption) (*RpcResponse, error)
}

type relayClient struct {
	cc grpc.ClientConnInterface
}

func NewRelayClient(cc grpc.ClientConnInterface) RelayClient {
	return &relayClient{cc}
}

func (c *relayClient) RelayHandle(ctx context.Context, in *InternalReq, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/pb.Relay/RelayHandle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RelayServer is the server API for Relay service.
// All implementations should embed UnimplementedRelayServer
// for forward compatibility
type RelayServer interface {
	RelayHandle(context.Context, *InternalReq) (*RpcResponse, error)
}

// UnimplementedRelayServer should be embedded to have forward compatible implementations.
type UnimplementedRelayServer struct {
}

func (UnimplementedRelayServer) RelayHandle(context.Context, *InternalReq) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RelayHandle not implemented")
}

// UnsafeRelayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RelayServer will
// result in compilation errors.
type UnsafeRelayServer interface {
	mustEmbedUnimplementedRelayServer()
}

func RegisterRelayServer(s grpc.ServiceRegistrar, srv RelayServer) {
	s.RegisterService(&Relay_ServiceDesc, srv)
}

func _Relay_RelayHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InternalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServer).RelayHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Relay/RelayHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServer).RelayHandle(ctx, req.(*InternalReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Relay_ServiceDesc is the grpc.ServiceDesc for Relay service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Relay_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Relay",
	HandlerType: (*RelayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RelayHandle",
			Handler:    _Relay_RelayHandle_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "snakemini/service.proto",
}

// RelayMonitorClient is the client API for RelayMonitor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RelayMonitorClient interface {
	Update(ctx context.Context, in *BroadcastConfigs, opts ...grpc.CallOption) (*ReplyEmpty, error)
}

type relayMonitorClient struct {
	cc grpc.ClientConnInterface
}

func NewRelayMonitorClient(cc grpc.ClientConnInterface) RelayMonitorClient {
	return &relayMonitorClient{cc}
}

func (c *relayMonitorClient) Update(ctx context.Context, in *BroadcastConfigs, opts ...grpc.CallOption) (*ReplyEmpty, error) {
	out := new(ReplyEmpty)
	err := c.cc.Invoke(ctx, "/pb.RelayMonitor/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RelayMonitorServer is the server API for RelayMonitor service.
// All implementations should embed UnimplementedRelayMonitorServer
// for forward compatibility
type RelayMonitorServer interface {
	Update(context.Context, *BroadcastConfigs) (*ReplyEmpty, error)
}

// UnimplementedRelayMonitorServer should be embedded to have forward compatible implementations.
type UnimplementedRelayMonitorServer struct {
}

func (UnimplementedRelayMonitorServer) Update(context.Context, *BroadcastConfigs) (*ReplyEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeRelayMonitorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RelayMonitorServer will
// result in compilation errors.
type UnsafeRelayMonitorServer interface {
	mustEmbedUnimplementedRelayMonitorServer()
}

func RegisterRelayMonitorServer(s grpc.ServiceRegistrar, srv RelayMonitorServer) {
	s.RegisterService(&RelayMonitor_ServiceDesc, srv)
}

func _RelayMonitor_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastConfigs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayMonitorServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RelayMonitor/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayMonitorServer).Update(ctx, req.(*BroadcastConfigs))
	}
	return interceptor(ctx, in, info, handler)
}

// RelayMonitor_ServiceDesc is the grpc.ServiceDesc for RelayMonitor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RelayMonitor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RelayMonitor",
	HandlerType: (*RelayMonitorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Update",
			Handler:    _RelayMonitor_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "snakemini/service.proto",
}

// SocialClient is the client API for Social service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SocialClient interface {
	Handle(ctx context.Context, in *InternalReq, opts ...grpc.CallOption) (*RpcResponse, error)
	Bind(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*BindResponse, error)
	Disconnect(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*ReplyEmpty, error)
	GroupNotify(ctx context.Context, in *GroupNotifyReq, opts ...grpc.CallOption) (*GroupNotifyRsp, error)
	CreateRoomChat(ctx context.Context, in *CreateRoomChatReq, opts ...grpc.CallOption) (*CreateRoomChatRsp, error)
}

type socialClient struct {
	cc grpc.ClientConnInterface
}

func NewSocialClient(cc grpc.ClientConnInterface) SocialClient {
	return &socialClient{cc}
}

func (c *socialClient) Handle(ctx context.Context, in *InternalReq, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/pb.Social/Handle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socialClient) Bind(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*BindResponse, error) {
	out := new(BindResponse)
	err := c.cc.Invoke(ctx, "/pb.Social/Bind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socialClient) Disconnect(ctx context.Context, in *UidRequest, opts ...grpc.CallOption) (*ReplyEmpty, error) {
	out := new(ReplyEmpty)
	err := c.cc.Invoke(ctx, "/pb.Social/Disconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socialClient) GroupNotify(ctx context.Context, in *GroupNotifyReq, opts ...grpc.CallOption) (*GroupNotifyRsp, error) {
	out := new(GroupNotifyRsp)
	err := c.cc.Invoke(ctx, "/pb.Social/GroupNotify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *socialClient) CreateRoomChat(ctx context.Context, in *CreateRoomChatReq, opts ...grpc.CallOption) (*CreateRoomChatRsp, error) {
	out := new(CreateRoomChatRsp)
	err := c.cc.Invoke(ctx, "/pb.Social/CreateRoomChat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SocialServer is the server API for Social service.
// All implementations should embed UnimplementedSocialServer
// for forward compatibility
type SocialServer interface {
	Handle(context.Context, *InternalReq) (*RpcResponse, error)
	Bind(context.Context, *UidRequest) (*BindResponse, error)
	Disconnect(context.Context, *UidRequest) (*ReplyEmpty, error)
	GroupNotify(context.Context, *GroupNotifyReq) (*GroupNotifyRsp, error)
	CreateRoomChat(context.Context, *CreateRoomChatReq) (*CreateRoomChatRsp, error)
}

// UnimplementedSocialServer should be embedded to have forward compatible implementations.
type UnimplementedSocialServer struct {
}

func (UnimplementedSocialServer) Handle(context.Context, *InternalReq) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Handle not implemented")
}
func (UnimplementedSocialServer) Bind(context.Context, *UidRequest) (*BindResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bind not implemented")
}
func (UnimplementedSocialServer) Disconnect(context.Context, *UidRequest) (*ReplyEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedSocialServer) GroupNotify(context.Context, *GroupNotifyReq) (*GroupNotifyRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GroupNotify not implemented")
}
func (UnimplementedSocialServer) CreateRoomChat(context.Context, *CreateRoomChatReq) (*CreateRoomChatRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRoomChat not implemented")
}

// UnsafeSocialServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SocialServer will
// result in compilation errors.
type UnsafeSocialServer interface {
	mustEmbedUnimplementedSocialServer()
}

func RegisterSocialServer(s grpc.ServiceRegistrar, srv SocialServer) {
	s.RegisterService(&Social_ServiceDesc, srv)
}

func _Social_Handle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InternalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocialServer).Handle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Social/Handle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocialServer).Handle(ctx, req.(*InternalReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Social_Bind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocialServer).Bind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Social/Bind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocialServer).Bind(ctx, req.(*UidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Social_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocialServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Social/Disconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocialServer).Disconnect(ctx, req.(*UidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Social_GroupNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupNotifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocialServer).GroupNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Social/GroupNotify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocialServer).GroupNotify(ctx, req.(*GroupNotifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Social_CreateRoomChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoomChatReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocialServer).CreateRoomChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Social/CreateRoomChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocialServer).CreateRoomChat(ctx, req.(*CreateRoomChatReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Social_ServiceDesc is the grpc.ServiceDesc for Social service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Social_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Social",
	HandlerType: (*SocialServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Handle",
			Handler:    _Social_Handle_Handler,
		},
		{
			MethodName: "Bind",
			Handler:    _Social_Bind_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _Social_Disconnect_Handler,
		},
		{
			MethodName: "GroupNotify",
			Handler:    _Social_GroupNotify_Handler,
		},
		{
			MethodName: "CreateRoomChat",
			Handler:    _Social_CreateRoomChat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "snakemini/service.proto",
}

// SocialMonitorClient is the client API for SocialMonitor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SocialMonitorClient interface {
	Update(ctx context.Context, in *BroadcastConfigs, opts ...grpc.CallOption) (*ReplyEmpty, error)
}

type socialMonitorClient struct {
	cc grpc.ClientConnInterface
}

func NewSocialMonitorClient(cc grpc.ClientConnInterface) SocialMonitorClient {
	return &socialMonitorClient{cc}
}

func (c *socialMonitorClient) Update(ctx context.Context, in *BroadcastConfigs, opts ...grpc.CallOption) (*ReplyEmpty, error) {
	out := new(ReplyEmpty)
	err := c.cc.Invoke(ctx, "/pb.SocialMonitor/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SocialMonitorServer is the server API for SocialMonitor service.
// All implementations should embed UnimplementedSocialMonitorServer
// for forward compatibility
type SocialMonitorServer interface {
	Update(context.Context, *BroadcastConfigs) (*ReplyEmpty, error)
}

// UnimplementedSocialMonitorServer should be embedded to have forward compatible implementations.
type UnimplementedSocialMonitorServer struct {
}

func (UnimplementedSocialMonitorServer) Update(context.Context, *BroadcastConfigs) (*ReplyEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeSocialMonitorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SocialMonitorServer will
// result in compilation errors.
type UnsafeSocialMonitorServer interface {
	mustEmbedUnimplementedSocialMonitorServer()
}

func RegisterSocialMonitorServer(s grpc.ServiceRegistrar, srv SocialMonitorServer) {
	s.RegisterService(&SocialMonitor_ServiceDesc, srv)
}

func _SocialMonitor_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastConfigs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SocialMonitorServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SocialMonitor/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SocialMonitorServer).Update(ctx, req.(*BroadcastConfigs))
	}
	return interceptor(ctx, in, info, handler)
}

// SocialMonitor_ServiceDesc is the grpc.ServiceDesc for SocialMonitor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SocialMonitor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.SocialMonitor",
	HandlerType: (*SocialMonitorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Update",
			Handler:    _SocialMonitor_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "snakemini/service.proto",
}
